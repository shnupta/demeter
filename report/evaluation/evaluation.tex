\chapter{Evaluation} \label{cha:Evaluation}
In this chapter the performance of our implementation is considered, in terms of VRFs and speedups, when compared with other similar solutions.


\section{Performance}
When compared with the implementation by Zhang and Wang \cite{ZhangConditionalQuasiMonteCarloMethod} our most accurate method does not show as large VRFs as theirs. For example, many of their arithmetic Asian delta estimates (ours are in Table \ref{tbl:vrfs-arithmetic}) are in the hundreds of millions whilst ours are in the hundreds of thousands. The implementation difference between this project and that in \cite{ZhangConditionalQuasiMonteCarloMethod} is the variance reduction technique used with QMC. We use the Brownian bridge path construction whereas Zhang and Wang use Gradient Principle Component Analysis (GPCA) \cite{gpca}. Whereas Brownian bridge is most effective for options whose terminal price is considered the most important value (e.g. European options), Asian options do not receive as great a variance reduction due to the form of their payoff. GPCA and PCA has been shown to reduce the effective dimension which makes QMC methods far more efficient, thus Zhang and Wang's implementation sees much better VRFs.

We can directly see the improvement of our implementation over that of the traditional pathwise and likelihood ratio methods simply from Tables \ref{tbl:vrfs-arithmetic}-\ref{tbl:vrfs-lookback}. Noting the significantly better VRFs of QMC+BB-CPW in chapter \ref{cha:Results}, financial institutions would achieve much greater accuracy through the use of our implementation. Given how important calculating Greeks is for these institutions, the benefits from using our implementation are far and wide: a more precise understanding of individual products behaviour to input parameters can allow for a far better understanding of the overall risk a company has to the market. This allows a company to perhaps take on larger positions with more confidence in their exposure and give them the ability to better react to market events. In a more specific situation, having more accurate estimates for Greeks leads to better pricing of products, which can give a market participant an advantage over competitors.

As noted in chapter \ref{cha:Results}, as the number of paths increase, the error in the estimates from QMC+BB-CPW become the smallest of all the methods. We are able to comfortably simulate $2^{19}$ paths on the Tesla T4 GPU, thus the ever-present trade off between speed and accuracy is the main consideration when applying the method. At $2^{15}$ paths (used for tables \ref{tbl:vrfs-arithmetic}-\ref{tbl:vrfs-lookback}) we see a single kernel run take around $0.8$ms for the Brownian bridge construction method and $0.2$ms for the others. The basic CPU implementation at $2^{15}$ paths takes ~$150$ms. As we move up to $2^{19}$ paths, QMC+BB-CPW requires $12$-$13$ms per kernel call and the other methods around $3$ms.

\section{Applicability and design}
Although only applied to three types of option, our method can be implemented for many types of options - both vanilla and exotic. This allows for a single algorithm to be applied to a large set of the products an institution may work with and reduces the need for many distinct methods that depend on the option type, whilst also achieving a higher accuracy. For example, estimating the gamma of many option types is not possible through pathwise alone and so an existing solution would be to apply the likelihood ratio in conjunction with pathwise. Any variant of QMC-CPW is able to calculate gamma estimates so broadens the range of products that an institution can handle with much less overhead.

The templated design of the simulation also allows other option types to be added easily, including those with multiple underlying assets. A redefinition of the path simulation and payoffs/Greeks formula for each type is all that is needed.We are also able to pull out Brownian bridge construction such that products can ingest the increments directly rather than the random normal variables $Z_i$.

One of the current limitations with the design is the lack of dynamic memory allocation, which would allow us to further encapsulate different product types and have a finer-grained control over simulation. In Savine's book \cite{savine2018aad}, a dynamic framework is presented in which options with a varying numbers of required random normal variables for simulation, can all follow the same path through the program. The implementation presented in this report has a fixed number of random numbers to generate at compile time and as such each product is required to take in all of those variables. This design was noted but the added difficulty of dealing with objects containing virtual functions in CUDA was seen as too far aside for the main objective of combining the QMC-CPW method and the parallel performance of the GPU. We recognise that the main objective of this project was experimental results and although added flexibility and a more polished product would be nice to have it was not a key element to begin with. We discuss these points later in section \ref{sec:FutureWork}.